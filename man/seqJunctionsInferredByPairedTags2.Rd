% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rearrangement-utils.R
\name{seqJunctionsInferredByPairedTags2}
\alias{seqJunctionsInferredByPairedTags2}
\title{Constructs a Rearrangement object of unlinked tag-clusters}
\usage{
seqJunctionsInferredByPairedTags2(preprocess, param)
}
\arguments{
\item{param}{A \code{RearrangementParams} object}

\item{aln.file}{A length-one character vector providing the file
path to a serialized R object of improper read pairs}

\item{bins}{A \code{GRanges} object.  This should be the
\code{bamRanges} of a \code{BamViews} object -- e.g., 1kb bins
along the genome with high mappability and good GC content.}
}
\description{
Identifies genomic intervals containing clusters of improper reads
 and constructs a Rearrangement object containing the unlinked
 clusters and the improper read pairs.
}
\details{
Read pairs are selected with parameters set in the
\code{RearrangementParams} object (denoted \code{params}) as follows:

1. the distance between the first and last read for a given pair
must be at least \code{rp_separation(params)}

2. Duplicate read pairs are dropped

3. For reads passing (1) and (2), the total number of reads aligned
to each bin in \code{bins} is counted. We exclude bins for which
the number of aligned reads is less than
\code{minNumberTagsPerCluster(params)}.  We use the remaining bins
to subset the read pairs object -- keeping only read pairs for
which the first or the last read overlaps a bin. Steps 1-3 are
performed by the function \code{filterPairedReads}.

4. Clusters of improper reads that pass (1), (2), and (3) are
  identified. In particular, we apply the function
  \code{unpairThenReduce} that first uncouples the read pairs and
  creates a single \code{GRanges} object.  The \code{GRanges}
  object is then reduced with argument \code{min.gapwidth} set to
  \code{minGapWidth(params)} (default is 1kb).  The interval for
  each cluster is given by the reduced ranges.  We keep only those
  intervals that have a width of at least
  \code{minClusterSize(params)} (default 115bp) and no larger than
  \code{maxClusterSize(params)} (default 5000bp).  In addition, we
  keep only those intervals for which the number of reads belonging
  to the interval is at least
  \code{minNumberTagsPerCluster(params)} (default 5). Step 4 is
  performed by the function \code{clusterTags}.

5.  Given a set of unlinked clusters and improper read pairs
  (filtered by steps 1-4), the Rearrangement constructor does the
  following:

  i. annotates the red pairs with a unique id for cluster membership

  ii. links the clusters (called linkedBins) (\code{linkClustersByReadPairs})

  iii.  partitions the improper read pairs according to whether
  they link two clusters (a read pair can belong to multiple paired
  clusters)

  iv.  maps each tag to a cluster

REFACTORING: Rearrangement should do nothing and should be able to
  construct an empty Rearrangement object if no data is provided.
  Move the functions that do step 5 out of the constructor.
}
\examples{
  data(pdata, package="trellis")
  rp <- RearrangementParams()
  ##
  ## The file of improper read pairs is large, so this is slow
  ##
  r <- seqJunctionsInferredByPairedTags2(pdata,
                                         param=rp)
  r
  ## improper read pairs that link the clusters
  head(improper(r))
  ## The linked tag cluster intervals
  linkedBins(r)
}
