---
title: "Identifying linked amplicons"
author: "Robert Scharpf"
date: \today
output: BiocStyle::pdf_document
vignette: >
  %\VignetteIndexEntry{Linked amplicons}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc} 
---

# Introduction

This vignette illustrates the workflow for identifying linked amplicons.

# Workflow

```{r packages}
suppressPackageStartupMessages(library(Rsamtools))
suppressPackageStartupMessages(library(trellis))
```

We assume the bin-level estimates of coverage have been normalized, transformed
to the log-scale, and segmented. We load the segmented log ratios from the
ovarian cell CGOV44T and the corresponding BamView.

```{r load_data}
cv.extdata <- system.file("extdata", package="trellis")
segs <- readRDS(file.path(cv.extdata, "cgov44t_segments.rds"))
extdata <- system.file("extdata", package="svbams")
bview <- BamViews(bamPaths=file.path(extdata, "cgov44t_revised.bam"))
```

Next, we load sequence- and germline-based filters.

```{r filters}
library(svfilters.hg19)
data(germline_filters)
```

A default set of parameters for linking amplicons can be generated using the function `ampliconParams`:

```{r params}
params <- ampliconParams()
```

An initial amplicon graph (with no edges) is constructed based on a hard
threshold of the segment means. The print method provides various summary
statistics of the data contained in this object, including the number of
amplicons, the number of links between the amplicons (currently 0), the total
size of the sequence-based filters (234.47 Mb), and the total size of the
amplicons.

```{r initialgraph}
params[["AMP_THR"]]
ag <- makeAGraph(segs, germline_filters, params)
print(ag)
```

The four high-copy focal amplicons in this initial graph serve as seeds. We next
evaluate whether any of the segments can be merged. In particular, we merge
adjacent segments having segment means that differ by less than
`MIN_SEGMEAN_DIFF`.

```{r joinNear}
params[["MIN_SEGMEAN_DIFF"]]
merged <- joinNearGRanges(ranges(ag), params)
names(merged) <- ampliconNames(merged)
nmerged <- length(ranges(ag)) - length(merged)
nmerged
```


We use improperly paired reads to link amplicons. First, we extract the
improperly paired reads and then we evaluate whether there are duplications
flanking the seed amplicons that can be linked to the seeds by the improperly
paired reads. In order to link the flanking segments to the seeds, we require
the adjacent segments to have mean log ratios consistent with a duplication
(see ```LOW_THR```).

```{r properly_paired}
params[["LOW_THR"]]
rp <- get_readpairs(ag, bamPaths(bview))
ag <- addFocalDupsFlankingAmplicon(ag, rp, params)
ag
```

TODO: what does this do. how does the graph change? What do these segments look
like?

```{r focalAmpDup}
qr <- focalAmpliconDupRanges(ag, params)
queryRanges(ag) <- qr
qr
```

TODO: Explain the steps below.

```{r improperly_paired}
irp <- get_improper_readpairs(ag, bamPaths(bview))
ag <- trellis:::linkFocalDups(ag, irp, params)
ag <- trellis:::linkAmplicons(ag, irp, edgeParam=params[["edge"]])
ag <- trellis:::linkNearAmplicons(ag, maxgap=params[["maxgap"]])
ag <- trellis:::filterSmallAmplicons (ag)
ag <- trellis:::setAmpliconGroups (ag)
ag <- trellis:::setGenes (ag, transcripts)
ag <- trellis:::setDrivers (ag, transcripts, clin_sign=TRUE)
ag <- trellis:::setDrivers (ag, transcripts, clin_sign=FALSE)
```

# Visualizations

In order to plot the linked amplicons as a graph, we load several package that support visualizations of graph objects. To reduce the footprint of trellis requirements, we leave these code chunks unevaluated.

```{r plotfun, eval=FALSE}
library(ggplot2)
library(gridExtra)
library(grid)
library(GGally)
library(network)
library(sna)
plot_amplicons <- function(ag, col_list=qualitativeColors()){
  if(length(ag)==0){
    message("No amplicons -- nothing to plot")
    return(invisible())
  }
  dark_colors <- c("#332288", "#661100", "#882255", "#AA4499")
  ##ar <- ampliconRanges(ag)
  ar <- nodes(ag)
  ##ar <- keepSeqlevels(ar, unique(chromosome(ar)))
  chroms <- sapply(strsplit(ar, ":"), "[", 1)
  sl <- unique(chroms)
  ##sl <- seqlevels(ar)
  L <- length(sl)
  L <- ifelse(L > 12, 12, L)
  ##sl <- factor(chromosome(ar), levels=sl)
  sl <- factor(chroms, levels=sl)
  color_nodes <- col_list[[L]][as.integer(sl)]
  g1 <- graph(ag)
  color_nodes <- setNames(color_nodes, nodes(g1))
  nodenames <- setNames(nodes(g1), nodes(g1))
  text_col <- setNames(rep("black", length(nodes(g1))), nodes(g1))
  text_col[color_nodes %in% dark_colors] <- "gray90"
  nodeRenderInfo(g1) <- list(label=nodenames, fill=color_nodes, textCol=text_col)
  ##nodeAttrs <- list(fillcolor=colors)
  nodeAttrs <- list(fillcolor=color_nodes)
  attrs <- list(node=list(shape="rectangle",
                          fixedsize=FALSE),
                graph=list(rankdir="LR"))
  graph_object <- layoutGraph(g1,
                              attrs=attrs,
                              nodeAttrs=nodeAttrs)
  ## if(numEdges(graph_object) > 0){
  ##   renderGraph(graph_object)
  ## } else plot(graph_object)
  graph_object
}

plotAmpGraph <- function(ag, transcripts, color.guide=FALSE){
  B <- svplots:::plot_amplicons(ag)
  B1 <- as(B, "graphAM")
  am <- B1@adjMat
  net <- network(am, directed=FALSE)
  chroms <- sapply(strsplit(colnames(am), ":"), "[", 1)
  ar <- ampliconRanges(ag)
  hits <- findOverlaps(ar, transcripts, maxgap=5000)
  cancer.con <- split(transcripts$cancer_connection[subjectHits(hits)],
                      queryHits(hits))
  is.driver <- sapply(cancer.con, any)
  is.driver2 <- rep(FALSE, ncol(am))
  is.driver2[as.integer(names(is.driver))] <- is.driver
  net %v% "chrom" <- chroms
  net %v% "driver" <- is.driver2
  B <- ggnet2(net,
              color="chrom",
              palette="Dark2",
              shape="driver",
              size="degree") +
    guides(size=FALSE,
           shape=FALSE,
           color=color.guide)
  B1 <- ggplotGrob(B)
  B1
}
```


```{r graph, eval=FALSE}
p4 <- plotAmpGraph(ag, transcripts, color.guide=guide_legend(title=""))
grid.arrange(p4)
```
