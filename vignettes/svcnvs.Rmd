---
title: "Overview of svcnvs package"
author: "Robert Scharpf"
date: \today
output: BiocStyle::pdf_document
vignette: >
  %\VignetteIndexEntry{Overview of svcnvs package}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc} 
---

# Introduction

This package is used to segment normalized coverage by circular binary
segmentation and to identify deletions and amplicons through a combination of
changes in normalized coverage and read pairs with aberrant spacing or
orientation. *Segmentation should probably be extracted into a separate package.*

# Preprocessing


Additional packages required for this vignette are the `svfilter.hg19` package
that contains various sequence filters for structural variant analyses and the
`svalignments` package that contains wrappers for extracting properly- and
improperly-paired reads from a BAM file.


```{r packages}
library(GenomicRanges)
library(Rsamtools)
library(svcnvs)
library(svfilters.hg19)
library(svalignments)
```

Next, we load an object containg the normalized and $\log_2$-transformed
coverage estimates ($\log_2$ ratios) in non-overlapping 1kb bins along the
genome. The $\log_2$ ratios were multipled by 1000, rounded to the nearest
integer, and saved as integers in a serialized R object to reduce the memory
footpring.

```{r views_filepath}
ddir <- system.file("extdata", package="svpreprocess", mustWork=TRUE)
cov.file <- file.path(ddir, "preprocessed_coverage.rds")
log_ratio <- readRDS(cov.file)/1000
data(bins1kb, package="svfilters.hg19")
seqlevels(bins1kb, pruning.mode="coarse") <- paste0("chr", c(1:22, "X"))
## !requires column to be named log_ratio!
bins1kb$log_ratio <- log_ratio
```

# Segmentation

So that our segmentation example runs quickly, we limit our analyses to
two chromosomes and sample every 10th bin.  Note, additional arguments can be passed to the `segment` function in the `DNAcopy` package.

```{r segment}
bins_subset <- bins1kb
seqlevels(bins_subset, pruning.mode="coarse") <- c("chr1", "chr2")
bins_subset <- bins_subset[ seq(1, length(bins_subset), 50) ]
g <- segmentBins(bins_subset)
g
```

The result is a `GRanges` object with segment means of log-normalized coverage in the `seg.mean` column.  Here, we load previously computed segments from the full dataset.

```{r segments}
path <- system.file("extdata", package="svcnvs")
data(segments, package="svcnvs")
```

## Plotting the genome

Plot the entire genome overlaying the segmentation data.

```{r genome, fig.width=8, fig.height=3}
bins1kb <- sort(bins1kb)
lrr.df <- as.data.frame(bins1kb[seq(1, length(bins1kb), 50)])
seg.df <- as.data.frame(segments)
library(ggplot2)
chromlabels <- setNames(c(1:22, "X"), seqlevels(bins1kb))
ggplot(lrr.df, aes(start, log_ratio)) +
  geom_point(size=0.1, color="gray") +
  geom_segment(data=seg.df,
               aes(x=start, xend=end, y=seg.mean, yend=seg.mean),
               color="black", inherit.aes=FALSE) +
  facet_grid(~seqnames, space="free", scales="free_x",
             labeller=as_labeller(chromlabels)) +
  theme(axis.text.x=element_blank(),
        panel.grid=element_blank(),
        panel.background=element_rect(fill="white"),
        axis.ticks.x=element_blank()) + xlab("") +
  ylab(expression(log[2](r)))
```


# Deletions

In additition to the segmented $\log_2$ ratios, the deletion analysis requires
improperly paired reads. Below, we specify the complete file path to a BAM file
provided by the `svbams` package and extract improperly paired reads from the
entire genome and an initial set of properly paired reads.

```{r views}
extdata <- system.file("extdata", package="svbams")
bam.file <- file.path(extdata, "cgov44t_revised.bam")
iparams <- improperAlignmentParams(what=c("flag", "mrnm", "mpos", "mapq"))
improper_rp <- getImproperAlignmentPairs(bam.file,
                                         param=iparams)
segs <- keepSeqlevels(segments, "chr15", pruning.mode="coarse")
del.gr <- reduce(segs[segs$seg.mean < hemizygousThr(DeletionParam())],
                 min.gapwidth=2000)
proper_rp <- properReadPairs(bam.file, gr=del.gr, DeletionParam())
read_pairs <- list(proper_del=proper_rp, improper=improper_rp)
```

Finally, we collect the bin-level summaries, the segmentation data, and the read
pair data  in a single list object:


```{r preprocess_data}
pdata <- preprocessData(bam.file=bam.file,
                        genome="hg19",
                        bins=bins1kb,
                        segments=segments,
                        read_pairs=read_pairs)
```

Below, we call segments as homozygous deletion (homozygous), homozygous deletion
supported by improperly paired reads (homozygous+), and hemizygous deletion
supported by improperly paired reads. For the purpose of identifying somatic
deletions without a matched normal, we exclude hemizygous deletions that are not
supported by improperly paired reads. With this toy dataset, we identify two
homozygous deletions and the calls are both `homozygous`.

```{r sv_deletions}
deletions <- sv_deletions(preprocess=pdata)
variant(deletions)
calls(deletions)
```

The improperly-paired reads supporting the `homozygous+` call can be extracted
as a `GAlignmentPairs` object from the second element of the `StructuralVariant` object.

```{r structural_variant}
improper(deletions[2])
```

# Amplicons

Amplicons can be identified using the same list data structure for the
preprocessed data.

```{r amplified_segments}
params <- ampliconParams()
ag <- svcnvs:::sv_amplicons2(pdata, params=params)
```

Note the object returned by `sv_amplicons` is a graph where the nodes are the
individual amplicons and the edges are links between amplicons given by
improperly paired reads. By default, with 30x coverage we require at least 5
improperly paired reads to support an edge. See `?ampliconParams` for customing
these settings.

# Plotting deletions

We will use the *ggplot2* and *gridExtra* packages for plotting the deletions.

```{r plot_libraries}
library(ggplot2)
suppressPackageStartupMessages(library(gridExtra))
library(scales)
```

In the following code chunk, we extract the genomic coordinates for the deletion
stored in the *deletion* object. To view the deletion in the context of the
surrounding region, we create a second *GRanges* object that includes 200kb of
the flanking genome on each side of the deletion.

```{r region_of_interest}
##
## region of interest (roi)
##
roi <- variant(deletion)
seqlevels(roi, pruning.mode="coarse") <- "chr15"
expand <- 200e3
roi2 <- GRanges(seqnames(roi), IRanges(start(roi)-expand,
                                       end(roi) + expand))
seqinfo(roi2) <- seqinfo(roi)
```

Next, we subset the views object to contain only the genomic bins in the region
of interest defined above. In addition, we create a data.frame containing all
the segments for this particular chromosome and sample and a data.frame
containing the preprocessed coverage.

```{r dataframes}
segs <- keepSeqlevels(segments, seqlevels(roi), pruning.mode="coarse")
segs.df <- as(segs, "data.frame")
hom.plus <- subsetByOverlaps(bins1kb, roi2)
df <- data.frame(logr=hom.plus$log_ratio,
                 start=start(hom.plus))
```

We restrict the y-axis limits to a suitable range for visualizing the log
ratios, thresholding log ratios that are extreme. We highlight the region
identified by the segmentation in the ggplot graphic (the boundaries for the
deletion are subsequently revised by the improperly paired reads as described in
the next section).

```{r plot_logratios}
ylim <- c(-9, 2)
df$logr <- svpreprocess::threshold(df$logr, ylim)
brks <- pretty(df$start, n=8)
region <- subsetByOverlaps(segs, roi)
region <- region[region$seg.mean < -1]
region <- as.data.frame(region)
xlim <- c(start(roi2), end(roi2))

A <- ggplot(df, aes(start, logr)) +
  geom_point(size=1, color="gray50") +
  scale_x_continuous(expand=c(0,0), breaks=brks, labels=brks/1e6)+
  scale_y_continuous(expand=c(0,0)) +
  geom_segment(data=segs.df,
               aes(x=start, xend=end, y=seg.mean, yend=seg.mean),
               size=1) +
  coord_cartesian(xlim=xlim, ylim=ylim) +
  ylab(expression(log[2]~ratio)) +
  geom_rect(data=region,
            aes(xmin=start, xmax=end, ymin=-Inf, ymax=+Inf),
            fill="steelblue", color="transparent", alpha=0.3,
            inherit.aes=FALSE) +
  theme(axis.text=element_text(size=10),
        axis.text.x=element_blank()) + xlab("") +
  annotate("text", x=xlim[1] + 15e3, y=-8, label="chr15", size=3)
A1 <- ggplotGrob(A)
```

## Plotting rearranged read pairs from a deletion object

In addition to the log ratios, we would like to visualize the rearranged read
pairs (read pairs with aberrant spacing or orientation with respect to the
reference genome) that support the deletion. The rearranged read pairs
supporting the deletion are encapsulated in the *deletion* object that we
already loaded. First, we pull read pairs flanking the candidate deletion that
have normal spacing and orientation. Because there are typically a large number
of the normal read pairs, we thin these using the function *thinReadPairs*.
Next, we melt these reads into a *data.frame* useful for plotting.

```{r rearranged_reads}
rps <- thinReadPairs(deletion)
rps <- svcnvs:::meltReadPairs(rps)
```

We again use *ggplot* to plot the data. Note the vertical dashed lines depict
the more precise boundaries of the deletion made possible by the improperly
paired (rearranged) reads. 

```{r plot_rearranged_reads}
colors <- c("#0072B2", "#009E73")
p <- ggplot(rps, aes(ymin=readpair-0.2, ymax=readpair+0.2,
                xmin=start/1e6, xmax=end/1e6, color=read,
                fill=read, group=readpair)) +
  geom_rect() +
  xlim(c(min(rps$start), max(rps$end))/1e6) +
  geom_line(aes(x=start/1e6, y=readpair)) +
  ylab("read pair index") +
  scale_x_continuous(breaks=pretty_breaks(5)) +
  geom_rect(data=region,
            aes(xmin=start/1e6, xmax=end/1e6, ymin=-Inf, ymax=+Inf),
            fill="steelblue", color="transparent", alpha=0.2,
            inherit.aes=FALSE) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) + 
  xlab("Mb") +
  theme(axis.text.x=element_text(size=7)) +
  guides(fill=FALSE, color=FALSE) +
  geom_vline(xintercept=c(start(roi)/1e6, end(roi)/1e6), linetype="dashed")
B <- ggplotGrob(p)
```


Finally, we make a composite graphic of the log ratios and rearranged reads.
Note, the vertical dashed lines show the revised deletion boundaries using the
improperly-paired reads that flank the new sequence junction formed as a result
of the deletion.

```{r composite}
grid.arrange(A1, B, ncol=1)
```

# Plotting amplicon graphs

See the amplicons vignette.



