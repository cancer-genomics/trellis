---
title: "Overview of svcnvs package"
author: "Robert Scharpf"
date: \today
output: BiocStyle::pdf_document
vignette: >
  %\VignetteIndexEntry{Overview of svcnvs package}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc} 
---

# Introduction

This package is used to segment normalized coverage by circular binary
segmentation and to identify deletions and amplicons through a combination of
changes in normalized coverage and read pairs with aberrant spacing or
orientation. *Segmentation should probably be extracted into a separate package.*

# Preprocessing

This vignette requires the *svpreprocess* package for loading a views for the
bin-level preprocessed coverage estimates. *TODO: Purpose of modular processing
is not to depend on the preprocessing package. Read in normalized coverage from
a GRanges object. Save to disk in the appropriate format and instantiate the
Views object below from scratch*.

```{r packages}
library(GenomicRanges)
library(svclasses)
library(svpreprocess)
library(svcnvs)
library(svfilters.hg19)
library(svalignments)
```

```{r pviews}
data(pview, package="svpreprocess")
```

Update the file path in the views object to file containing the preprocessed coverage.

```{r views_filepath}
ddir <- system.file("extdata", package="svpreprocess", mustWork=TRUE)
cov.file <- file.path(ddir, "preprocessed_coverage.rds")
paths(pview) <- cov.file
```

# Segmentation

TODO

```{r segments}
data(segments, package="svcnvs")
```

# Deletions

The deletion analysis uses improperly paired reads as well as the segmented
normalized coverage. We use two additional 'views' objects to faciliate these
analyses: (i) a views object for the BAM files (`BamViews`) and (ii) a views
object for the improperly paired reads (`AlignmentViews`). We instantiate these
views in the following code chunk:

```{r views}
library(Rsamtools)
extdata <- system.file("extdata", package="svbams")
id <- "CGOV44T.bam"
id.rds <- paste0(id, ".rds")
bamfile <- file.path(extdata, id)
bview <- Rsamtools::BamViews(bamPaths=bamfile)
seqinfo(bamRanges(bview)) <- seqinfo(segments)["chr15", ]
```

So that the examples run very quickly in this vignette, we limit our deletion
analysis to chromosome 15. 

```{r seqinfo}
segs <- keepSeqlevels(segments, "chr15", pruning.mode="coarse")
region.of.interest <- GRanges("chr15", IRanges(63201003-10e3, 63209243+10e3))
seqinfo(region.of.interest) <- seqinfo(segs)
segs <- segs[overlapsAny(segs, region.of.interest)]
segs
```

Next, we extract improperly paired reads from this region by passing `segs` to
the `which` argument of the `improperAlignmentParams` function.

```{r improper_pairs}
segs2 <- expandGRanges(segs, 10e3)
iparams <- improperAlignmentParams(which=reduce(segs2), mapqFilter=30)
## TODO mapq_thr should be part of iparams.  Don't need use.mcols
irp <- getImproperAlignmentPairs(bamfile, iparams)
length(irp)
irp.file <- tempfile()
saveRDS(irp, file=irp.file)
aview <- AlignmentViews2(bview, path=irp.file)
```

Filters for germline CNVs and sequence artifacts are available from the
`svfilters` package. Here, we load the hg19 filters.

```{r germline_filters}
data(germline_filters, package="svfilters.hg19")
filters <- reduceGenomeFilters(germline_filters)
```


```{r sv_deletions}
dparam <- DeletionParam()
deletion <- sv_deletions(gr=segs,
                         bview=bview,
                         aview=aview,
                         pview=pview,
                         gr_filters=filters,
                         param=dparam)
```

# Amplicons

To illustrate how amplicons are identified and linked by improperly paired
reads, we load segmentation results from chromosomes 5 and 8.

```{r amplified_segments}
cv.extdata <- system.file("extdata", package="svcnvs")
segs <- readRDS(file.path(cv.extdata, "cgov44t_segments.rds"))
aparams <- ampliconParams()
ag <- sv_amplicons(bview=bview,
                   segs=segs,
                   amplicon_filters=germline_filters,
                   params=aparams,
                   transcripts=transcripts)
ag
```

# Plotting deletions

We will use the *ggplot2* and *gridExtra* packages for plotting the deletions.

```{r plot_libraries}
library(ggplot2)
suppressPackageStartupMessages(library(gridExtra))
library(scales)
```

In the following code chunk, we extract the genomic coordinates for the deletion
stored in the *deletion* object. To view the deletion in the context of the
surrounding region, we create a second *GRanges* object that includes 200kb of
the flanking genome on each side of the deletion.

```{r region_of_interest}
suppressPackageStartupMessages(library(SummarizedExperiment))
##
## region of interest (roi)
##
roi <- variant(deletion)
roi <- keepSeqlevels(roi, as.character(seqnames(roi)))
expand <- 200e3
roi2 <- GRanges(seqnames(roi), IRanges(start(roi)-expand,
                                       end(roi) + expand))
seqinfo(roi2) <- seqinfo(roi)
```

Next, we subset the views object to contain only the genomic bins in the region
of interest defined above. In addition, we create a data.frame containing all
the segments for this particular chromosome and sample and a data.frame
containing the preprocessed coverage.

```{r dataframes}
pview2 <- pview[queryHits(findOverlaps(rowRanges(pview), roi2)), ]
segs <- keepSeqlevels(segments, seqlevels(roi), pruning.mode="coarse")
segs.df <- as(segs, "data.frame")
df <- data.frame(logr=assays(pview2)[, 1],
                 start=start(rowRanges(pview2)))
```

We restrict the y-axis limits to a suitable range for visualizing the log
ratios, thresholding log ratios that are extreme. We highlight the region
identified by the segmentation in the ggplot graphic (the boundaries for the
deletion are subsequently revised by the improperly paired reads as described in
the next section).

```{r plot_logratios}
ylim <- c(-9, 2)
df$logr <- threshold(df$logr, ylim)
brks <- pretty(df$start, n=8)
region <- subsetByOverlaps(segs, roi)
region <- region[region$seg.mean < -1]
region <- as.data.frame(region)
xlim <- c(start(roi2), end(roi2))

A <- ggplot(df, aes(start, logr)) +
  geom_point(size=1, color="gray50") +
  scale_x_continuous(expand=c(0,0), breaks=brks, labels=brks/1e6)+
  scale_y_continuous(expand=c(0,0)) +
  geom_segment(data=segs.df,
               aes(x=start, xend=end, y=seg.mean, yend=seg.mean),
               size=1) +
  coord_cartesian(xlim=xlim, ylim=ylim) +
  ylab(expression(log[2]~ratio)) +
  geom_rect(data=region,
            aes(xmin=start, xmax=end, ymin=-Inf, ymax=+Inf),
            fill="steelblue", color="transparent", alpha=0.3,
            inherit.aes=FALSE) +
  theme(axis.text=element_text(size=10),
        axis.text.x=element_blank()) + xlab("") +
  annotate("text", x=xlim[1] + 15e3, y=-8, label="chr15", size=3)
A1 <- ggplotGrob(A)
```

## Plotting rearranged read pairs from a deletion object

In addition to the log ratios, we would like to visualize the rearranged read
pairs (read pairs with aberrant spacing or orientation with respect to the
reference genome) that support the deletion. The rearranged read pairs
supporting the deletion are encapsulated in the *deletion* object that we
already loaded. First, we pull read pairs flanking the candidate deletion that
have normal spacing and orientation. Because there are typically a large number
of the normal read pairs, we thin these using the function *thinReadPairs*.
Next, we melt these reads into a *data.frame* useful for plotting.

```{r rearranged_reads}
rps <- thinReadPairs(deletion)
rps <- svcnvs:::meltReadPairs(rps)
```

We again use *ggplot* to plot the data. Note the vertical dashed lines depict
the more precise boundaries of the deletion made possible by the improperly
paired (rearranged) reads.

```{r plot_rearranged_reads}
colors <- c("#0072B2", "#009E73")
p <- ggplot(rps, aes(ymin=readpair-0.2, ymax=readpair+0.2,
                xmin=start/1e6, xmax=end/1e6, color=read,
                fill=read, group=readpair)) +
  geom_rect() +
  xlim(c(min(rps$start), max(rps$end))/1e6) +
  geom_line(aes(x=start/1e6, y=readpair)) +
  ylab("read pair index") +
  scale_x_continuous(breaks=pretty_breaks(5)) +
  geom_rect(data=region,
            aes(xmin=start/1e6, xmax=end/1e6, ymin=-Inf, ymax=+Inf),
            fill="steelblue", color="transparent", alpha=0.2,
            inherit.aes=FALSE) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) + 
  xlab("Mb") +
  theme(axis.text.x=element_text(size=7)) +
  guides(fill=FALSE, color=FALSE) +
  geom_vline(xintercept=c(start(roi)/1e6, end(roi)/1e6), linetype="dashed")
B <- ggplotGrob(p)
```


Finally, we make a composite graphic of the log ratios and rearranged reads:

```{r compoisite}
grid.arrange(A1, B, ncol=1)
```

# Plotting amplicon graphs

See the amplicons vignette.



