---
title: "Overview of svcnvs package"
author: "Robert Scharpf"
date: \today
output: BiocStyle::pdf_document
vignette: >
  %\VignetteIndexEntry{Overview of svcnvs package}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc} 
---

# Introduction

This package is used to segment normalized coverage by circular binary
segmentation and to identify deletions and amplicons through a combination of
changes in normalized coverage and read pairs with aberrant spacing or
orientation. *Segmentation should probably be extracted into a separate
package.*

# Workflow

This vignette requires the *svpreprocess* package for loading a views for the
bin-level preprocessed coverage estimates. *TODO: Purpose of modular processing
is not to depend on the preprocessing package. Read in normalized coverage from
a GRanges object. Save to disk in the appropriate format and instantiate the
Views object below from scratch*.

```{r packages}
library(svpreprocess)
library(svcnvs)
```

```{r views}
data(pview, package="svpreprocess")
```

Update the file path in the views object to file containing the preprocessed coverage.

```{r views_filepath}
ddir <- system.file("extdata", package="svpreprocess", mustWork=TRUE)
cov.file <- file.path(ddir, "preprocessed_coverage.rds")
pview@bamPaths <- cov.file
```

TODO: show how deletions are called from the views object above.

Here, we are loading results from segmentation of the preprocessed coverage as
well as an object of called deletions from the *sv_deletions* function for the
ovarian cancer cell line CGOV44T.

```{r deletion}
data(segments, package="svcnvs")
data(deletion, package="svcnvs")
```

# Plotting deletions

We will use the *ggplot2* and *gridExtra* packages for plotting the deletions.

```{r plot_libraries}
library(ggplot2)
library(gridExtra)
library(scales)
```

In the following code chunk, we extract the genomic coordinates for the deletion
stored in the *deletion* object. To view the deletion in the context of the
surrounding region, we create a second *GRanges* object that includes 200kb of
the flanking genome on each side of the deletion.

```{r region_of_interest}
library(SummarizedExperiment)
##
## region of interest (roi)
##
roi <- variant(deletion)
roi <- keepSeqlevels(roi, as.character(seqnames(roi)))
expand <- 200e3
roi2 <- GRanges(seqnames(roi), IRanges(start(roi)-expand,
                                       end(roi) + expand))
seqinfo(roi2) <- seqinfo(roi)
```

Next, we subset the views object to contain only the genomic bins in the region
of interest defined above. In addition, we create a data.frame containing all
the segments for this particular chromosome and sample and a data.frame
containing the preprocessed coverage.

```{r dataframes}
pview2 <- pview[queryHits(findOverlaps(rowRanges(pview), roi2)), ]
segs <- keepSeqlevels(segments, seqlevels(roi), pruning.mode="coarse")
segs.df <- as(segs, "data.frame")
df <- data.frame(logr=assays(pview2)[, 1],
                 start=start(rowRanges(pview2)))
```

We restrict the y-axis limits to a suitable range for visualizing the log
ratios, thresholding log ratios that are extreme. We highlight the region
identified by the segmentation in the ggplot graphic and use dashed lines to
indicate the more precise deletion boundaries identified from the rearranged
read pairs that were used in the *sv_deletion* function. 

```{r plot_logratios}
ylim <- c(-9, 2)
df$logr <- threshold(df$logr, ylim)
brks <- pretty(df$start, n=8)
region <- subsetByOverlaps(segs, roi)
region <- region[region$seg.mean < -1]
region <- as.data.frame(region)
xlim <- c(start(roi2), end(roi2))

A <- ggplot(df, aes(start, logr)) +
  geom_point(size=1, color="gray50") +
  scale_x_continuous(expand=c(0,0), breaks=brks, labels=brks/1e6)+
  scale_y_continuous(expand=c(0,0)) +
  geom_segment(data=segs.df,
               aes(x=start, xend=end, y=seg.mean, yend=seg.mean),
               size=1) +
  coord_cartesian(xlim=xlim, ylim=ylim) +
  ylab(expression(log[2]~ratio)) +
  geom_rect(data=region,
            aes(xmin=start, xmax=end, ymin=-Inf, ymax=+Inf),
            fill="steelblue", color="transparent", alpha=0.3,
            inherit.aes=FALSE) +
  theme(axis.text=element_text(size=10),
        axis.text.x=element_blank()) + xlab("") +
  annotate("text", x=xlim[1] + 15e3, y=-8, label="chr15", size=3)
A1 <- ggplotGrob(A)
```

## Plotting rearranged read pairs from a deletion object

In addition to the log ratios, we would like to visualize the rearranged read
pairs (read pairs with aberrant spacing or orientation with respect to the
reference genome) that support the deletion. The rearranged read pairs
supporting the deletion are encapsulated in the *deletion* object that we
already loaded. First, we pull read pairs flanking the candidate deletion that
have normal spacing and orientation. Because there are typically a large number
of the normal read pairs, we thin these using the function *thinReadPairs*.
Next, we melt these reads into a *data.frame* useful for plotting.

```{r rearranged_reads}
rps <- thinReadPairs(deletion)
rps <- meltReadPairs(rps)
```

We again use *ggplot* to plot the data:

```{r plot_rearranged_reads}
colors <- c("#0072B2", "#009E73")
p <- ggplot(rps, aes(ymin=readpair-0.2, ymax=readpair+0.2,
                xmin=start/1e6, xmax=end/1e6, color=read,
                fill=read, group=readpair)) +
  geom_rect() +
  xlim(c(min(rps$start), max(rps$end))/1e6) +
  geom_line(aes(x=start/1e6, y=readpair)) +
  ylab("read pair index") +
  scale_x_continuous(breaks=pretty_breaks(5)) +
  geom_rect(data=region,
            aes(xmin=start/1e6, xmax=end/1e6, ymin=-Inf, ymax=+Inf),
            fill="steelblue", color="transparent", alpha=0.2,
            inherit.aes=FALSE) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) + 
  xlab("Mb") +
  theme(axis.text.x=element_text(size=7)) +
  guides(fill=FALSE, color=FALSE)
B <- ggplotGrob(p)
```


Finally, we make a composite graphic of the log ratios and rearranged reads:

```{r compoisite}
grid.arrange(A1, B, ncol=1)
```

## Extract rearranged read pairs from a BAM file for a region of interest

This section describes how to extract rearranged read pairs from a BAM file for
a specific genomic region of interest (e.g., a possible deletion). In the
following code chunk, we load the ```svbams``` package which contains a small
bam files for this particular region of chr15.  

```{r svbams}
library(Rsamtools)
library(svbams)
path <- system.file("extdata", package="svbams")
```

Next, we create a BamViews object that will contain metadata on the bamfiles.

```{r bamviews}
bampath <- list.files(path, pattern="cgov44t.bam$", full.names=TRUE)
bview <- BamViews(bamPaths=bampath)
```

Improper paired alignments can be extracted using the svalignments package.

```{r improper_alignments}
##
## create an AlignmentViews object
##
param <- improperAlignmentParams()
irp <- getImproperAlignmentPairs(bview, param,
                                 mapq_thr=30,
                                 use.mcols=TRUE)
```

Extract read pairs

```{r readpairs, eval=FALSE}
library(svalignments)
prp <- properReadPairs(bam_path=bamPaths(aview),
                       gr=roi2,
                       param=DeletionParam())
prp_index <- initializeProperIndex2(cnv, prp, zoom.out=1)
irp <- addImproperReadPairs2(cnv, aview, param=param)
irp_index1 <- initializeImproperIndex2(cnv, irp, param)
irp_index2 <- updateImproperIndex2(cnv, irp, maxgap=2e3)
irp_index3 <- .match_index_variant(irp_index1, cnv, irp_index2)
sv <- StructuralVariant(variant=cnv,
                        proper=prp,
                        improper=irp,
                        copynumber=cnv$seg.mean,
                        calls=cncalls,
                        index_proper=prp_index,
                        index_improper=irp_index3)

```




