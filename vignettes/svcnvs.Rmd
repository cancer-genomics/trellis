---
title: "Overview of svcnvs package"
author: "Robert Scharpf, Daniel Bruhm"
date: \today
output: BiocStyle::pdf_document
vignette: >
  %\VignetteIndexEntry{Overview of svcnvs package}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc} 
---

# Introduction

The svcnvs package is used to identify deletions and amplicons from Whole Genome Sequencing (WGS) data through a combination of changes in normalized coverage and read pairs with aberrant spacing or orientation.

Additional packages required for this vignette are the `svfilters.hg19` package
that contains various sequence filters for structural variant analyses and the
`svalignments` package that contains wrappers for extracting properly- and
improperly-paired reads from a BAM file.  We also employ functions from `RSamtools` and `GenomicRanges`.

This package requires that normalized coverage is calculated for a set of bins in the package `svfilters.hg19` (or `svfilters.hg18`).  See the `svpreprocess` vignette for comprehensive documentaion on generating normalized coverage.  This process can take some time on large bam files so for the purpose of this tutorial we've distributed sample preprocessed coverage data from the `svpreprocess` package.

# Preprocessing

Loading packages required for this analysis.

```{r packages}
library(GenomicRanges)
library(Rsamtools)
library(trellis)
library(svfilters.hg19)
```

We first load an object from the `svpreprocess` package containing normalized and $\log_2$-transformed coverage estimates ($\log_2$ ratios) in non-overlapping 1kb bins along the genome (see `svpreprocess` to generate $\log_2$ ratios). The $\log_2$ ratios were multipled by 1000, rounded to the nearest integer, and saved as integers in a serialized R object to reduce the memory footpring.  We append the $\log_2$ ratios to the `GRanges` object bins1kb from the `svfilters.hg19` package and remove chromosome Y from the analysis as this sample is of female origin. Note that in this instance we are using `svfilters.hg19` because we aligned our reads to the hg19 reference genome.  There is an `svfilters.hg18` package for if your reads were aligned to hg18, and an `svfilters.hg38` package will be available in the future to support alignments to hg38.

```{r views_filepath}
ddir <- system.file("extdata", package="svpreprocess", mustWork=TRUE)
cov.file <- file.path(ddir, "preprocessed_coverage.rds")
log_ratio <- readRDS(cov.file)/1000
data(bins1kb, package="svfilters.hg19")
seqlevels(bins1kb, pruning.mode="coarse") <- paste0("chr", c(1:22, "X"))
## !requires column to be named log_ratio!
bins1kb$log_ratio <- log_ratio
```

# Segmentation


Next, we segment the $\log_2$ ratios using the Circular Binary Segmentation algorithm to achieve estimated copy number states across the genome. 
So that our segmentation example runs quickly, we limit our analyses to
two chromosomes and sample every 10th bin.  Note, additional arguments can be passed to the `segment` function in the `DNAcopy` package.

```{r segment}
bins_subset <- bins1kb
seqlevels(bins_subset, pruning.mode="coarse") <- c("chr1", "chr2")
bins_subset <- bins_subset[ seq(1, length(bins_subset), 50) ]
g <- segmentBins(bins_subset)
g
```

The result is a `GRanges` object with segment means of log-normalized coverage in the `seg.mean` column.  Here, we load previously computed segments from the full dataset.


```{r segments}
path <- system.file("extdata", package="svcnvs")
data(segments, package="svcnvs")
```

To generate this segments object on your own data use the `segmentBins` function.  
```{r segments2, eval=FALSE}
segments <- segmentBins(bins1kb, param = SegmentParam())
```

We've created a `SegmentParam` class (see `?SegmentParam`) as a container for a subset of the parameters for the `segment` function in the `DNAcopy package`.  Running `SegmentParam()` creates a SegmentParam obect with default values that we've found generally work well on most datasets for these following slots:

``` {r segments3, eval=TRUE}
SegmentParam()
```

If you would like to alter the CBS parameters you can easily create your own `SegmentParam` object.  For example, suppose you want to run CBS with alpha = 0.01 instead of 0.001:

``` {r segments4, eval=FALSE}
x <- SegmentParam(alpha = 0.01, undo.splits = "sdundo", undo.SD = 2, verbose = 0) 
segments <- segmentBins(bins1kb, param = x)
```

Any additional arguments to `DNAcopy::segment` can be incorporated into `segmentBins()` by using them as arguments to `segmentBins`.  For example, a user may want to use min.with = 2 instead of the default value of 3:

``` {r segments5, eval=FALSE}
segments <- segmentBins(bins1kb, param = SegmentParam(), min.width = 2)
```

See `?DNAcopy::segment` for a complete list of parameters.

## Plotting the genome

We routinely visualize the segmented $\log_2$ ratios of the entire genome to get an overview of the data.  An example using the `ggplot2` library follows.

```{r genome, fig.width=8, fig.height=4, warning=FALSE}
bins1kb <- sort(bins1kb)
lrr.df <- as.data.frame(bins1kb[seq(1, length(bins1kb), 50)])
seg.df <- as.data.frame(segments)
library(ggplot2)
chromlabels <- setNames(c(1:22, "X"), seqlevels(bins1kb))
ggplot(lrr.df, aes(start, log_ratio)) +
  geom_point(size=0.1, color="steelblue", alpha = 0.1) +
  geom_segment(data=seg.df,
               aes(x=start, xend=end, y=seg.mean, yend=seg.mean),
               color="black", inherit.aes=FALSE) +
  facet_grid(~seqnames, space="free", scales="free_x",
             labeller=as_labeller(chromlabels)) +
  theme(axis.text.x=element_blank(),
        panel.grid=element_blank(),
        panel.background=element_rect(fill="white"),
        axis.ticks.x=element_blank(), 
        strip.text.x = element_text(size = 3)) + 
  xlab("") +
  ylab(expression(log[2](r))) + 
  ylim(c(-3, 3))
```

It is evident from visual inspection that this sample has numerous structural alterations.  We will proceed to integrate read pair information with these segmented $\log_2$ ratios to strengthen CNV calls.         


# Deletions

In additition to the segmented $\log_2$ ratios, the deletion analysis requires
improperly paired reads. Below, we specify the complete file path to the BAM file
used for this analysis that is provided by the `svbams` package. We extract improperly paired reads from the entire genome and an initial set of properly paired reads from a region on chromosome 15.

```{r views}
extdata <- system.file("extdata", package="svbams")
bam.file <- file.path(extdata, "cgov44t_revised.bam")
iparams <- improperAlignmentParams(what=c("flag", "mrnm", "mpos", "mapq"))
improper_rp <- getImproperAlignmentPairs(bam.file,
                                         param=iparams, 
                                         build="hg19")
segs <- keepSeqlevels(segments, "chr15", pruning.mode="coarse")
del.gr <- reduce(segs[segs$seg.mean < hemizygousThr(DeletionParam())],
                 min.gapwidth=2000)
proper_rp <- properReadPairs(bam.file, gr=del.gr, DeletionParam())
read_pairs <- list(proper_del=proper_rp, improper=improper_rp)
```

We collect the bin-level summaries ($\log_2$ ratios), the segmentation data, and the read
pair data in a single list object:


```{r preprocess_data}
pdata <- preprocessData(bam.file=bam.file,
                        genome="hg19",
                        bins=bins1kb,
                        segments=segments,
                        read_pairs=read_pairs)
```

Below, we call segments as homozygous deletion (homozygous), homozygous deletion
supported by improperly paired reads (homozygous+), hemizygous deletion (hemizygous), and hemizygous deletion
supported by improperly paired reads (hemizygous). For the purpose of identifying somatic
deletions without a matched normal, we exclude hemizygous deletions that are not
supported by improperly paired reads. With this toy dataset, we identify 16
possible homozygous deletions and the calls are both `homozygous` except onw which is `homozygous+`.

```{r sv_deletions}
deletions <- sv_deletions(preprocess=pdata)
variant(deletions)
calls(deletions)
```

The improperly-paired reads supporting the `homozygous+` call can be extracted
as a `GAlignmentPairs` object from the twelth element of the `StructuralVariant` object.

```{r structural_variant}
improper(deletions[12])
```

# Amplicons

Amplicons can be identified using the same list data structure for the
preprocessed data we called `pdata` as was used in the *Deletions* section.  

```{r amplified_segments}
ag <- sv_amplicons2(pdata, params=ampliconParams())
```

Note the object returned by `sv_amplicons` is a graph where the nodes are the
individual amplicons and the edges are links between amplicons given by
improperly paired reads. By default, with 30x coverage we require at least 5
improperly paired reads to support an edge. See `?ampliconParams` for customing
these settings.

# Plotting deletions

We will use the *ggplot2* and *gridExtra* packages for plotting the deletions.

```{r plot_libraries}
library(ggplot2)
suppressPackageStartupMessages(library(gridExtra))
library(scales)
```

In the following code chunk, we extract the genomic coordinates for a deletion
stored in a *StructuralVariant* object distributed with this package. To view the deletion in the context of the
surrounding region, we create a second *GRanges* object that includes 200kb of
the flanking genome on each side of the deletion.

```{r region_of_interest}
data(deletion)
roi <- variant(deletion) # region of interest 
seqlevels(roi, pruning.mode="coarse") <- "chr15"
expand <- 200e3
roi2 <- GRanges(seqnames(roi), IRanges(start(roi)-expand,
                                       end(roi) + expand))
seqinfo(roi2) <- seqinfo(roi)
```

Next, we subset the views object to contain only the genomic bins in the region
of interest defined above. In addition, we create a data.frame containing all
the segments for this particular chromosome and sample and a data.frame
containing the preprocessed coverage.

```{r dataframes}
segs <- keepSeqlevels(segments, seqlevels(roi), pruning.mode="coarse")
segs.df <- as(segs, "data.frame")
hom.plus <- subsetByOverlaps(bins1kb, roi2)
df <- data.frame(logr=hom.plus$log_ratio,
                 start=start(hom.plus))
```

We restrict the y-axis limits to a suitable range for visualizing the log
ratios, thresholding log ratios that are extreme. We highlight the region
identified by the segmentation in the ggplot graphic (the boundaries for the
deletion are subsequently revised by the improperly paired reads as described in
the next section).

```{r plot_logratios}
ylim <- c(-9, 2)
df$logr <- svpreprocess::threshold(df$logr, ylim)
brks <- pretty(df$start, n=8)
region <- subsetByOverlaps(segs, roi)
region <- region[region$seg.mean < -1]
region <- as.data.frame(region)
xlim <- c(start(roi2), end(roi2))

A <- ggplot(df, aes(start, logr)) +
  geom_point(size=1, color="gray50") +
  scale_x_continuous(expand=c(0,0), breaks=brks, labels=brks/1e6)+
  scale_y_continuous(expand=c(0,0)) +
  geom_segment(data=segs.df,
               aes(x=start, xend=end, y=seg.mean, yend=seg.mean),
               size=1) +
  coord_cartesian(xlim=xlim, ylim=ylim) +
  ylab(expression(log[2]~ratio)) +
  geom_rect(data=region,
            aes(xmin=start, xmax=end, ymin=-Inf, ymax=+Inf),
            fill="steelblue", color="transparent", alpha=0.3,
            inherit.aes=FALSE) +
  theme(axis.text=element_text(size=10),
        axis.text.x=element_blank()) + xlab("") +
  annotate("text", x=xlim[1] + 15e3, y=-8, label="chr15", size=3)
A1 <- ggplotGrob(A)
```

## Plotting rearranged read pairs from a deletion object

In addition to the log ratios, we would like to visualize the rearranged read
pairs (read pairs with aberrant spacing or orientation with respect to the
reference genome) that support the deletion. The rearranged read pairs
supporting the deletion are encapsulated in the *deletion* object that we
already loaded. First, we pull read pairs flanking the candidate deletion that
have normal spacing and orientation. Because there are typically a large number
of the normal read pairs, we thin these using the function *thinReadPairs*.
Next, we melt these reads into a *data.frame* useful for plotting.

```{r rearranged_reads}
rps <- thinReadPairs(deletion)
rps <- svcnvs:::meltReadPairs(rps)
```

We again use *ggplot* to plot the data. Note the vertical dashed lines depict
the more precise boundaries of the deletion made possible by the improperly
paired (rearranged) reads. 

```{r plot_rearranged_reads}
colors <- c("#0072B2", "#009E73")
p <- ggplot(rps, aes(ymin=readpair-0.2, ymax=readpair+0.2,
                xmin=start/1e6, xmax=end/1e6, color=read,
                fill=read, group=readpair)) +
  geom_rect() +
  xlim(c(min(rps$start), max(rps$end))/1e6) +
  geom_line(aes(x=start/1e6, y=readpair)) +
  ylab("read pair index") +
  scale_x_continuous(breaks=pretty_breaks(5)) +
  geom_rect(data=region,
            aes(xmin=start/1e6, xmax=end/1e6, ymin=-Inf, ymax=+Inf),
            fill="steelblue", color="transparent", alpha=0.2,
            inherit.aes=FALSE) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) + 
  xlab("Mb") +
  theme(axis.text.x=element_text(size=7)) +
  guides(fill=FALSE, color=FALSE) +
  geom_vline(xintercept=c(start(roi)/1e6, end(roi)/1e6), linetype="dashed")
B <- ggplotGrob(p)
```


Finally, we make a composite graphic of the log ratios and rearranged reads.
Note, the vertical dashed lines show the revised deletion boundaries using the
improperly-paired reads that flank the new sequence junction formed as a result
of the deletion.

```{r composite}
grid.arrange(A1, B, ncol=1)
```

# Plotting amplicon graphs

See the amplicons vignette.



